;
; Lab3.asm
;
; Created: 9/28/2018 12:07:40 PM
; Author : Zachary
;

.equ IO_BASE_ADDR = 0x73000
.equ SRAM_BASE_ADDR = 0x420000
.equ SP_INIT = 0x3FFF
.equ DELAY_INNER	= 0xF8			
.equ DELAY_OUTER	= 0x10
.equ TIME_DELAY = 10
.equ TABLE_SIZE = 459

.dseg 
.org 0x2000
Table2: .byte 459

.cseg
.org 0xF000
Table:
	.db 0x4d, 0x61, 0x6b, 0x69, 0x6e, 0x67, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x77, 0x61, 0x79, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x20, 0x74, 0x6f, 0x64, 0x61, 0x79, 0x20, 0x74, 0x61, 0x6b, 0x65, 0x73, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x20, 0x79, 0x6f, 0x75, 0x27, 0x76, 0x65, 0x20, 0x67, 0x6f, 0x74, 0x2e, 0x0a, 0x54, 0x61, 0x6b, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6b, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x77, 0x6f, 0x72, 0x72, 0x69, 0x65, 0x73, 0x2c, 0x20, 0x73, 0x75, 0x72, 0x65, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x68, 0x65, 0x6c, 0x70, 0x20, 0x61, 0x20, 0x6c, 0x6f, 0x74, 0x2e, 0x0a, 0x57, 0x6f, 0x75, 0x6c, 0x64, 0x6e, 0x27, 0x74, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6c, 0x69, 0x6b, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x67, 0x65, 0x74, 0x20, 0x61, 0x77, 0x61, 0x79, 0x3f, 0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x67, 0x6f, 0x0a, 0x57, 0x68, 0x65, 0x72, 0x65, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x62, 0x6f, 0x64, 0x79, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x73, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x0a, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x79, 0x27, 0x72, 0x65, 0x20, 0x61, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x20, 0x67, 0x6c, 0x61, 0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x63, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x77, 0x61, 0x6e, 0x6e, 0x61, 0x20, 0x62, 0x65, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x73, 0x65, 0x65, 0x2c, 0x0a, 0x6f, 0x75, 0x72, 0x20, 0x74, 0x72, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x77, 0x61, 0x6e, 0x6e, 0x61, 0x20, 0x62, 0x65, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x62, 0x6f, 0x64, 0x79, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x73, 0x0a, 0x59, 0x6f, 0x75, 0x72, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x77, 0x61, 0x6e, 0x6e, 0x61, 0x20, 0x67, 0x6f, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x70, 0x65, 0x6f, 0x70, 0x6c, 0x65, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x2c, 0x0a, 0x70, 0x65, 0x6f, 0x70, 0x6c, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x2c, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x77, 0x61, 0x6e, 0x6e, 0x61, 0x20, 0x67, 0x6f, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x62, 0x6f, 0x64, 0x79, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x73, 0x0a, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x20

.org 0x0000
	rjmp MAIN

.org 0x200
MAIN:
	;ldi YL, low(SP_INIT)
	;out CPU_SPL, YL
	;ldi YH, high(SP_INIT)
	;out CPU_SPH, YH
	;rcall INIT_EBI
	;rcall LOAD_TABLE
	;rcall READ_BACK_DATA
	;rcall LOAD_SRAM_ADDRESS
	ldi r16, 0x01
	sts EBI_CTRL, r16
	ldi r16, 0x33
	sts PORTH_DIRSET, r16
	sts PORTH_OUTSET, r16
	ldi r16, 0xff
	sts PORTK_DIRSET, r16
	ldi r16, byte2(SRAM_BASE_ADDR)
	sts EBI_CS0_BASEADDR, r16
	ldi r16, byte3(SRAM_BASE_ADDR)
	sts EBI_CS0_BASEADDR+1, r16
	ldi r16, 0b00011101
	sts EBI_CS0_CTRLA, r16
	rcall LOAD_SRAM_ADDRESS
	ldi r16, 0xff
	st X+, r16
	ldi r16, 0x01
	st X, r16
	dec XL
	ld r16, X


END:
	rjmp END


LOAD_IO_ADDRESS:
	push r16
	ldi XL, byte1(IO_BASE_ADDR)
	ldi XH, byte2(IO_BASE_ADDR)
	ldi r16, byte3(IO_BASE_ADDR)
	out CPU_RAMPX, r16
	pop r16
	ret

LOAD_SRAM_ADDRESS:
	push r16
	ldi XL, byte1(SRAM_BASE_ADDR)
	ldi XH, byte2(SRAM_BASE_ADDR)
	ldi r16, byte3(SRAM_BASE_ADDR)
	out CPU_RAMPX, r16
	pop r16
	ret

INIT_EBI:
	push r16
	ldi r16, 0xFF
	sts PORTK_DIR, r16
	ldi r16, 0x37	;enable RE, WE, ALE1, CS0, CS1
	sts PORTH_DIRSET, r16
	sts PORTH_OUTSET, r16
	ldi r16, 0x33
	sts PORTH_OUT, r16

	ldi r16, (1 << EBI_IFMODE0_bp)
	sts EBI_CTRL, r16
	ldi ZL, low(EBI_CS1_BASEADDR)
	ldi ZH, high(EBI_CS1_BASEADDR)
	ldi r16, byte2(IO_BASE_ADDR)
	st Z+, r16
	ldi r16, byte3(IO_BASE_ADDR)
	st z, r16
	ldi r16, (EBI_CS_ASPACE_512B_gc | EBI_CS_MODE_SRAM_gc)
	sts EBI_CS1_CTRLA, r16
	ldi ZL, low(EBI_CS0_BASEADDR)
	ldi ZH, high(EBI_CS0_BASEADDR)
	ldi r16, byte2(SRAM_BASE_ADDR)
	st Z+, r16
	ldi r16, byte3(SRAM_BASE_ADDR)
	st Z, r16
	;ldi r16, (EBI_CS_ASPACE_32KB_gc | EBI_CS_MODE_SRAM_gc)
	ldi r16, 0b00011101
	sts EBI_CS0_CTRLA, r16
	pop r16
	ret

DELAY_10MS:
	push r18						;push the value onto the stack to preserve its value
	push r19						;push the value onto the stack to preserve its value
	ldi r18, DELAY_INNER			;load r18 with the inner loop timer
	dec r18							;decrement the counter because we are in the first loop
	ldi r19, DELAY_OUTER			;load the register with the outer loop counter
	dec r19							;decrement the counter because we are in the first loop

LOOP1:
	cpi r18, 0x00					;compare the inner loop value with 0
	breq CHECK_LOOP					;if r18 is equal to zero then the inner loop has completed
	dec r18							;if not then decrement the counter
	rjmp LOOP1						;return to the top of the inner loop

CHECK_LOOP:
	cpi r19, 0x00					;compare outer loop counter with 0
	breq DELAY_10MS_END				;if they are equal then we branch to the end of the subroutine
	ldi r18, DELAY_INNER			;reload the register with the inner loop value
	dec r19							;decrement the outer loop counter
	rjmp LOOP1						;jump back to the start of a new inner loop

DELAY_10MS_END:
	pop r19							;pop the value off the stack to preserve the original register value
	pop r18							;pop the value off the stack to preserve original register value
	ret								;return from the subroutine

;--------------------------------------------------------------------------------------------
DELAY_X_10MS:
	cpi r17, 0x00					;compare the r17 register with 00 to check for a zero delay function  call
	breq END_DELAY_X_WO_POP			;if the value is zero(zero delay requested) jump to the end of the subroutine without popping value off the stack
	push r17						;push the value of r17 onto the stack
	dec r17							;decrement r17

LOOP_TEST:
	rcall DELAY_10MS				;call the delay function
	cpi r17, 0x00					;compare the counter value to zero
	breq END_DELAY_X_10MS			;if they are equal branch to the end of the function
	dec r17							;decrement the counter
	rjmp LOOP_TEST					;jump to the top of the loop test

END_DELAY_X_10MS:
	pop r17							;pop the value from the stack to preserve its value

END_DELAY_X_WO_POP:	
	ret

LOAD_TABLE:
	push r16
	ldi ZL, byte1(Table << 1)
	ldi ZH, byte2(Table << 1)
	ldi r16, byte3(Table << 1)
	out CPU_RAMPZ, r16
	ldi YL, byte1(TABLE_SIZE)
	ldi YH, byte2(TABLE_SIZE)
	ldi XL, byte1(SRAM_BASE_ADDR)
	ldi XH, byte2(SRAM_BASE_ADDR)
	ldi r16, byte3(SRAM_BASE_ADDR)
	out CPU_RAMPX, r16

LOAD_TABLE_LOOP:
	elpm r16, Z+
	st X+, r16
	rjmp LOAD_TABLE_CHECK_CNT

LOAD_TABLE_CHECK_CNT:
	cpi YL, 0x00
	breq CHECK_HIGH_BYTE
	dec YL
	rjmp LOAD_TABLE_LOOP

CHECK_HIGH_BYTE:
	cpi YH, 0x00
	breq LOAD_TABLE_END
	dec YH
	ldi YL, 0xff
	rjmp LOAD_TABLE_LOOP
	
LOAD_TABLE_END:
	ld r16, X+
	ld r16, X+
	pop r16
	ret

READ_BACK_DATA:
	rcall LOAD_SRAM_ADDRESS
	ldi YL, byte1(TABLE_SIZE)
	ldi YH, byte2(TABLE_SIZE)
	ldi ZL, byte1(Table2)
	ldi ZH, byte2(Table2)
	ldi r16, 0x00 
	out CPU_RAMPZ, r16
	ld r16, X+
	ld r16, X+
	ld r16, X+
	ld r16, X+
	ld r16, X+
	ld r16, X+
	ret

	
